import { createLogger, type Plugin } from 'vite';
import fs from 'fs';
import type { Resource, ResourceLanguage } from 'i18next';
import {
  generateModuleTypeDefinition,
  generateResourceTypeDefinition,
  parseResourceFiles,
} from 'i18next-utilities-core';
import type { I18NextTypedLoaderOptions } from './types';

export type { I18NextTypedLoaderOptions };

const virtualModuleId = 'virtual:i18next-typed-loader';
const resolvedVirtualModuleId = '\0' + virtualModuleId;

const generateAndWriteDefinitions = (
  defaultBundle: ResourceLanguage,
  bundle: Resource,
  options: I18NextTypedLoaderOptions,
): void => {
  const resourceDefinition = generateResourceTypeDefinition(
    defaultBundle,
    options,
  );
  const moduleDefinition = generateModuleTypeDefinition(
    virtualModuleId,
    Object.keys(bundle),
  );

  const header = `/**
 * WARNING: This file is generated by vite-plugin-typed-i18next-loader. Do not modify it manually.
 */\n\n`;

  fs.writeFileSync(
    options.dtsOutputFile || './src/types/i18next.d.ts',
    header + resourceDefinition,
  );
  fs.writeFileSync(
    options.virtualModuleDtsOutputFile || './src/types/i18next-virtual.d.ts',
    header + moduleDefinition,
  );
};

const factory = (options: I18NextTypedLoaderOptions): Plugin => {
  let _watchedFiles: string[] = [];
  let _bundle: Resource = {};

  const logger = createLogger(options.logLevel ?? 'warn', {
    prefix: '[typed-i18next-loader]',
  });

  const plugin: Plugin = {
    name: 'vite-plugin-typed-i18next-loader',
    resolveId(id) {
      if (id === virtualModuleId) {
        const { files, bundle, defaultBundle } = parseResourceFiles(
          options,
          logger,
        );

        _watchedFiles = files;
        _bundle = bundle;

        generateAndWriteDefinitions(defaultBundle, bundle, options);

        logger.info(
          `Type definitions generated for default locale: ${options.defaultLocale || 'en'}`,
          { timestamp: true },
        );
        logger.info(
          `Definitions saved to: ${options.dtsOutputFile || './src/types/i18next.d.ts'}`,
          { timestamp: true },
        );

        return resolvedVirtualModuleId;
      }

      return null;
    },
    load(id) {
      if (id !== resolvedVirtualModuleId) {
        return null;
      }

      _watchedFiles.forEach((file) => this.addWatchFile(file));

      return `export default ${JSON.stringify(_bundle)}`;
    },
    handleHotUpdate({ server, file }) {
      if (!_watchedFiles.includes(file)) {
        return;
      }

      const module = server.moduleGraph.getModuleById(resolvedVirtualModuleId);

      if (module) {
        const { bundle, defaultBundle, files } = parseResourceFiles(
          options,
          logger,
        );

        _watchedFiles = files;
        _bundle = bundle;

        generateAndWriteDefinitions(defaultBundle, bundle, options);

        server.moduleGraph.invalidateModule(module);
      }
    },
  };

  return plugin;
};

export default factory;
