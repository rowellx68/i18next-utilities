import { createUnplugin, type UnpluginFactory } from 'unplugin';
import {
  I18NextTypedLogger,
  I18NextTypedOptions,
  parseResourceFiles,
  generateModuleTypeDefinition,
  generateResourceTypeDefinition,
} from 'i18next-utilities-core';
import type { Resource, ResourceLanguage } from 'i18next';
import fs from 'node:fs';
import { consola } from 'consola';

export type I18NextTypedLoaderOptions = {
  /**
   * Output file destination for the generated types.
   * @default './src/types/i18next.d.ts'
   */
  dtsOutputFile?: string;

  /**
   * Output file destination for the generated virtual module types.
   * @default './src/types/i18next-virtual.d.ts'
   */
  virtualModuleDtsOutputFile?: string;
} & I18NextTypedOptions;

const virtualModuleId = 'virtual:i18next-typed-loader';
const resolvedVirtualModuleId = '\0' + virtualModuleId;

const pluginName = 'unplugin-typed-i18next-loader';
const vitePluginName = 'vite-plugin-typed-i18next-loader';

const generateAndWriteDefinitions = (
  defaultBundle: ResourceLanguage,
  bundle: Resource,
  options: I18NextTypedLoaderOptions,
): void => {
  const resourceDefinition = generateResourceTypeDefinition(
    defaultBundle,
    options,
  );
  const moduleDefinition = generateModuleTypeDefinition(
    virtualModuleId,
    Object.keys(bundle),
  );

  const header = `/**
 * WARNING: This file is generated by typed-i18next-loader. Do not modify it manually.
 */\n\n`;

  fs.writeFileSync(
    options.dtsOutputFile || './src/types/i18next.d.ts',
    header + resourceDefinition,
  );
  fs.writeFileSync(
    options.virtualModuleDtsOutputFile || './src/types/i18next-virtual.d.ts',
    header + moduleDefinition,
  );
};

export const unpluginFactory: UnpluginFactory<I18NextTypedLoaderOptions> = (
  options,
) => {
  const logger: I18NextTypedLogger = {
    info: consola.info,
    warn: consola.warn,
    error: consola.error,
  };

  let _watchedFiles: string[] = [];
  let _bundle: Resource = {};
  let _defaultBundle: ResourceLanguage = {};

  return [
    {
      name: pluginName,
      enforce: 'pre',
      buildStart() {
        const { files, bundle, defaultBundle } = parseResourceFiles(
          options,
          logger,
        );

        _watchedFiles = files;
        _bundle = bundle;
        _defaultBundle = defaultBundle;

        generateAndWriteDefinitions(_defaultBundle, _bundle, options);
      },
      webpack(compiler) {
        compiler.hooks.beforeRun.tapPromise(pluginName, async () => {
          const { files, bundle, defaultBundle } = parseResourceFiles(
            options,
            logger,
          );

          _watchedFiles = files;
          _bundle = bundle;
          _defaultBundle = defaultBundle;

          generateAndWriteDefinitions(_defaultBundle, _bundle, options);
        });
      },
    },
    {
      name: 'i18next-typed-loader',
      resolveId(id) {
        if (id !== virtualModuleId) {
          return null;
        }

        return resolvedVirtualModuleId;
      },
      load(id) {
        if (id !== resolvedVirtualModuleId) {
          return null;
        }

        _watchedFiles.forEach((file) => this.addWatchFile(file));

        return `export default ${JSON.stringify(_bundle)}`;
      },
      vite: {
        name: vitePluginName,
        handleHotUpdate({ server, file }) {
          if (!_watchedFiles.includes(file)) {
            return;
          }

          const module = server.moduleGraph.getModuleById(
            resolvedVirtualModuleId,
          );

          if (module) {
            const { bundle, defaultBundle, files } = parseResourceFiles(
              options,
              logger,
            );

            _watchedFiles = files;
            _bundle = bundle;
            _defaultBundle = defaultBundle;

            generateAndWriteDefinitions(_defaultBundle, _bundle, options);

            server.moduleGraph.invalidateModule(module);
          }
        },
      },
    },
  ];
};

export const unplugin = /* @__PURE__ */ createUnplugin(unpluginFactory);

export default unplugin;
